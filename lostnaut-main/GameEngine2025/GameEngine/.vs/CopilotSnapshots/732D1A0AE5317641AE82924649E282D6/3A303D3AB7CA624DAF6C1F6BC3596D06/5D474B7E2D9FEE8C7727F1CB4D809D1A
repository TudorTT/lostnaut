#include "collision.h"

bool Platform::resolvePoint(glm::vec3& point, float eyeHeight) const
{
	glm::vec3 minW, maxW;
	getWorldAABB(minW, maxW);

	// Check XZ overlap (point projection on XZ plane)
	bool insideXZ = (point.x >= minW.x && point.x <= maxW.x) &&
		(point.z >= minW.z && point.z <= maxW.z);

	if (!insideXZ) return false;

	float topY = maxW.y;
	float bottomY = minW.y;
	float allowedTopY = topY + eyeHeight + 0.5f;

	const float collisionMargin = 2.0f;

	printf("Point Y: %f, TopY: %f, AllowedTopY: %f, BottomY: %f\n", point.y, topY, allowedTopY, bottomY);

	// Collision with TOP of platform (landing on it from above)
	if (point.y >= topY && point.y < allowedTopY)
	{
		point.y = allowedTopY;
		return true;
	}

	// Collision with BOTTOM of platform (hitting ceiling from below)
	if (point.y <= bottomY && point.y > bottomY - eyeHeight)
	{
		point.y = bottomY - eyeHeight;
		return true;
	}

	// Collision with SIDE of platform (player is vertically inside the platform)
	if (point.y > bottomY && point.y < topY)
	{
		// Calculate distance to each side
		float distToLeft = point.x - minW.x;
		float distToRight = maxW.x - point.x;
		float distToBack = point.z - minW.z;
		float distToFront = maxW.z - point.z;

		// Find the smallest distance (closest side)
		float minDist = std::min({ distToLeft, distToRight, distToBack, distToFront });

		// Push the player out from the closest side
		if (minDist == distToLeft)
		{
			point.x = minW.x;
			printf("side: left\n");
		}
		else if (minDist == distToRight)
		{
			point.x = maxW.x;
			printf("side: right\n");
		}
		else if (minDist == distToBack)
		{
			point.z = minW.z;
			printf("side: back\n");
		}
		else // distToFront
		{
			point.z = maxW.z;
			printf("side: front\n");
		}

		return true;
	}

	return false;
}