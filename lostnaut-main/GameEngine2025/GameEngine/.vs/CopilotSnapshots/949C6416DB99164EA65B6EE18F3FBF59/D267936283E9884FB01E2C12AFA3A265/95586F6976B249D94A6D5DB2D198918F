#include "collision.h"
#include <algorithm>
#include <cstdio>

CollisionManager::CollisionManager()
    : collisionMargin(0.1f)
    , debugOutput(false)
{
}

CollisionManager::~CollisionManager()
{
    // Don't delete collidables - we don't own them
    collidables.clear();
}

void CollisionManager::addCollidable(ICollidable* collidable)
{
    if (collidable)
    {
        // Avoid duplicates
        auto it = std::find(collidables.begin(), collidables.end(), collidable);
        if (it == collidables.end())
        {
            collidables.push_back(collidable);
        }
    }
}

void CollisionManager::removeCollidable(ICollidable* collidable)
{
    auto it = std::find(collidables.begin(), collidables.end(), collidable);
    if (it != collidables.end())
    {
        collidables.erase(it);
    }
}

void CollisionManager::clearAll()
{
    collidables.clear();
}

const char* CollisionManager::faceToString(ContactFace face)
{
    switch (face)
    {
        case ContactFace::Top:    return "TOP";
        case ContactFace::Bottom: return "BOTTOM";
        case ContactFace::Left:   return "LEFT";
        case ContactFace::Right:  return "RIGHT";
        case ContactFace::Front:  return "FRONT";
        case ContactFace::Back:   return "BACK";
        default:                  return "NONE";
    }
}

bool CollisionManager::resolvePointAgainstAll(glm::vec3& point, float eyeHeight)
{
    bool anyResolved = false;
    lastCollision = CollisionInfo(); // Reset last collision info
    
    for (ICollidable* collidable : collidables)
    {
        if (collidable && collidable->isCollisionEnabled())
        {
            glm::vec3 minW, maxW;
            collidable->getWorldAABB(minW, maxW);
            
            ContactFace face;
            if (resolvePointAgainstAABB(minW, maxW, point, eyeHeight, face))
            {
                anyResolved = true;
                
                // Store collision info
                lastCollision.collidable = collidable;
                lastCollision.face = face;
                lastCollision.resolvedPosition = point;
                
                // Print collision info if debug is enabled
                if (debugOutput)
                {
                    printf("Collision with '%s' on %s face\n", 
                           collidable->getName(), 
                           faceToString(face));
                }
            }
        }
    }
    
    return anyResolved;
}

bool CollisionManager::resolvePoint(const ICollidable* collidable, glm::vec3& point, float eyeHeight)
{
    if (!collidable || !collidable->isCollisionEnabled())
        return false;

    glm::vec3 minW, maxW;
    collidable->getWorldAABB(minW, maxW);

    ContactFace face;
    return resolvePointAgainstAABB(minW, maxW, point, eyeHeight, face);
}

bool CollisionManager::resolvePointAgainstAABB(const glm::vec3& minW, const glm::vec3& maxW,
                                                glm::vec3& point, float eyeHeight, ContactFace& outFace)
{
    outFace = ContactFace::None;

    // Player's feet position (point is eye position, feet are below by eyeHeight)
    float feetY = point.y - eyeHeight;

    // Check XZ overlap (point projection on XZ plane)
    bool insideXZ = (point.x >= minW.x && point.x <= maxW.x) &&
                    (point.z >= minW.z && point.z <= maxW.z);

    if (!insideXZ) 
        return false;

    float topY = maxW.y;
    float bottomY = minW.y;

    // Collision with TOP of platform (landing on it - feet are at or below the top surface)
    if (feetY <= topY && feetY >= topY - collisionMargin - eyeHeight && point.y > topY)
    {
        // Place feet on top of platform
        point.y = topY + eyeHeight + collisionMargin;
        outFace = ContactFace::Top;
        return true;
    }

    // Collision with BOTTOM of platform (hitting head on ceiling from below)
    // Player's head (point.y) is hitting the bottom of the platform
    if (point.y >= bottomY && point.y <= bottomY + collisionMargin && feetY < bottomY)
    {
        // Push player's head down below the platform bottom
        point.y = bottomY - collisionMargin;
        outFace = ContactFace::Bottom;
        return true;
    }

    // Collision with SIDE of platform (player is vertically overlapping the platform)
    if (feetY < topY && point.y > bottomY)
    {
        // Calculate distance to each side
        float distToLeft = point.x - minW.x;
        float distToRight = maxW.x - point.x;
        float distToBack = point.z - minW.z;
        float distToFront = maxW.z - point.z;

        // Find the smallest distance (closest side)
        float minDist = std::min({ distToLeft, distToRight, distToBack, distToFront });

        // Push the player out from the closest side
        if (minDist == distToLeft)
        {
            point.x = minW.x - collisionMargin;
            outFace = ContactFace::Left;
        }
        else if (minDist == distToRight)
        {
            point.x = maxW.x + collisionMargin;
            outFace = ContactFace::Right;
        }
        else if (minDist == distToBack)
        {
            point.z = minW.z - collisionMargin;
            outFace = ContactFace::Back;
        }
        else // distToFront
        {
            point.z = maxW.z + collisionMargin;
            outFace = ContactFace::Front;
        }

        return true;
    }

    return false;
}

bool CollisionManager::isPointInsideAABB(const ICollidable* collidable, const glm::vec3& point) const
{
    if (!collidable)
        return false;

    glm::vec3 minW, maxW;
    collidable->getWorldAABB(minW, maxW);

    return (point.x >= minW.x && point.x <= maxW.x) &&
           (point.y >= minW.y && point.y <= maxW.y) &&
           (point.z >= minW.z && point.z <= maxW.z);
}