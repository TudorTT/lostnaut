#pragma once
#include "../Model Loading/mesh.h"
#include "../Shaders/shader.h"
#include <glm.hpp>
#include <gtc/matrix_transform.hpp>
#include <vector>

class Platform
{
private:
	Mesh mesh;
	glm::vec3 position;
	glm::vec3 rotation; // Euler degrees
	glm::vec3 scale;

	// mesh-space bounds (computed once)
	glm::vec3 meshMin;
	glm::vec3 meshMax;

	void computeMeshBounds();
	glm::mat4 getModelMatrix() const;

public:
	Platform(const Mesh& mesh);
	void setPosition(const glm::vec3& p) { position = p; }
	void setRotation(const glm::vec3& r) { rotation = r; }
	void setScale(const glm::vec3& s) { scale = s; }

	// Draw using provided view/projection matrices (keeps main.cpp clean)
	void draw(Shader& shader, const glm::mat4& view, const glm::mat4& projection) const;

	// World-space AABB
	void getWorldAABB(glm::vec3& outMin, glm::vec3& outMax) const;

	// Resolve point penetration against platform top.
	// If point is horizontally over platform and below top + eyeHeight,
	// this moves point.y up to top + eyeHeight and returns true.
	bool resolvePoint(glm::vec3& point, float eyeHeight) const;

	// Contact face enumeration
	enum class ContactFace { None, Top, Bottom, Side };

	// Get contact information: if the given player point is contacting the platform
	// returns true and fills outPlatformPoint with the closest point on the platform
	// surface and outPlayerPoint with the original player point. This does NOT mutate the player point.
	// Also fills outFace with which face is contacted (Top/Bottom/Side).
	bool getContactInfo(const glm::vec3& playerPoint, glm::vec3& outPlatformPoint, glm::vec3& outPlayerPoint, ContactFace& outFace) const;

	// Helper to print contact information to the console for debugging.
	void printContactInfo(const glm::vec3& playerPoint) const;
};