#pragma once
#include "../Model Loading/mesh.h"
#include "../Shaders/shader.h"
#include <glm.hpp>
#include <gtc/matrix_transform.hpp>
#include <vector>
#include <unordered_map>

// Forward declare Platform to avoid circular includes
namespace Objects { class Platform; }
class Platform;

class CollisionManager
{
public:
    enum class ContactFace { None, Top, Bottom, Side };

    CollisionManager();
    ~CollisionManager();

    // Resolve point against a platform. Returns true if adjusted.
    bool resolvePoint(const class Platform* platform, glm::vec3& point, float eyeHeight);

    // Get contact info for debugging: fills out platformPoint, outPlayerPoint and outFace. Returns true if within XZ bounds.
    bool getContactInfo(const class Platform* platform, const glm::vec3& playerPoint, glm::vec3& outPlatformPoint, glm::vec3& outPlayerPoint, ContactFace& outFace) const;

    // Invalidate platform cache (call when platform transforms change)
    void invalidateCache(const class Platform* platform);

private:
    struct AABB { glm::vec3 min; glm::vec3 max; };

    // cache world AABB per platform pointer
    mutable std::unordered_map<const Platform*, AABB> aabbCache;

    // helper to compute or retrieve cached AABB
    const AABB& getAABB(const Platform* platform) const;
};

class Collision
{
	bool resolveCollisionPlayer(glm::vec3& point, float eyeHeight) const;

};