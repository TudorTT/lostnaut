#include "collision.h"
#include <algorithm>
#include <cstdio>

CollisionManager::CollisionManager()
    : collisionMargin(0.1f)
    , debugOutput(false)
{
}

CollisionManager::~CollisionManager()
{
    // Don't delete collidables - we don't own them
    collidables.clear();
}

void CollisionManager::addCollidable(ICollidable* collidable)
{
    if (collidable)
    {
        // Avoid duplicates
        auto it = std::find(collidables.begin(), collidables.end(), collidable);
        if (it == collidables.end())
        {
            collidables.push_back(collidable);
        }
    }
}

void CollisionManager::removeCollidable(ICollidable* collidable)
{
    auto it = std::find(collidables.begin(), collidables.end(), collidable);
    if (it != collidables.end())
    {
        collidables.erase(it);
    }
}

void CollisionManager::clearAll()
{
    collidables.clear();
}

bool CollisionManager::resolvePointAgainstAll(glm::vec3& point, float eyeHeight)
{
    bool anyResolved = false;
    
    for (ICollidable* collidable : collidables)
    {
        if (collidable && collidable->isCollisionEnabled())
        {
            if (resolvePoint(collidable, point, eyeHeight))
            {
                anyResolved = true;
            }
        }
    }
    
    return anyResolved;
}

bool CollisionManager::resolvePoint(const ICollidable* collidable, glm::vec3& point, float eyeHeight)
{
    if (!collidable || !collidable->isCollisionEnabled())
        return false;

    glm::vec3 minW, maxW;
    collidable->getWorldAABB(minW, maxW);

    ContactFace face;
    return resolvePointAgainstAABB(minW, maxW, point, eyeHeight, face);
}

bool CollisionManager::resolvePointAgainstAABB(const glm::vec3& minW, const glm::vec3& maxW,
                                                glm::vec3& point, float eyeHeight, ContactFace& outFace)
{
    outFace = ContactFace::None;

    // Check XZ overlap (point projection on XZ plane)
    bool insideXZ = (point.x >= minW.x && point.x <= maxW.x) &&
                    (point.z >= minW.z && point.z <= maxW.z);

    if (!insideXZ) 
        return false;

    float topY = maxW.y;
    float bottomY = minW.y;
    float allowedTopY = topY + eyeHeight + collisionMargin;

    if (debugOutput)
    {
        printf("Point Y: %f, TopY: %f, AllowedTopY: %f, BottomY: %f\n", 
               point.y, topY, allowedTopY, bottomY);
    }

    // Collision with TOP of platform (landing on it from above)
    if (point.y >= topY && point.y < allowedTopY)
    {
        point.y = allowedTopY;
        outFace = ContactFace::Top;
        return true;
    }

    // Collision with BOTTOM of platform (hitting ceiling from below)
    if (point.y <= bottomY && point.y > bottomY - eyeHeight)
    {
        point.y = bottomY - eyeHeight - collisionMargin;
        outFace = ContactFace::Bottom;
        return true;
    }

    // Collision with SIDE of platform (player is vertically inside the platform)
    if (point.y > bottomY && point.y < topY)
    {
        // Calculate distance to each side
        float distToLeft = point.x - minW.x;
        float distToRight = maxW.x - point.x;
        float distToBack = point.z - minW.z;
        float distToFront = maxW.z - point.z;

        // Find the smallest distance (closest side)
        float minDist = std::min({ distToLeft, distToRight, distToBack, distToFront });

        // Push the player out from the closest side
        if (minDist == distToLeft)
        {
            point.x = minW.x - collisionMargin;
            outFace = ContactFace::Left;
            if (debugOutput) printf("side: left\n");
        }
        else if (minDist == distToRight)
        {
            point.x = maxW.x + collisionMargin;
            outFace = ContactFace::Right;
            if (debugOutput) printf("side: right\n");
        }
        else if (minDist == distToBack)
        {
            point.z = minW.z - collisionMargin;
            outFace = ContactFace::Back;
            if (debugOutput) printf("side: back\n");
        }
        else // distToFront
        {
            point.z = maxW.z + collisionMargin;
            outFace = ContactFace::Front;
            if (debugOutput) printf("side: front\n");
        }

        return true;
    }

    return false;
}

bool CollisionManager::getContactInfo(const ICollidable* collidable, const glm::vec3& point, float eyeHeight,
                                       glm::vec3& outPushDirection, ContactFace& outFace) const
{
    if (!collidable)
    {
        outFace = ContactFace::None;
        outPushDirection = glm::vec3(0.0f);
        return false;
    }

    glm::vec3 minW, maxW;
    collidable->getWorldAABB(minW, maxW);

    // Check XZ overlap
    bool insideXZ = (point.x >= minW.x && point.x <= maxW.x) &&
                    (point.z >= minW.z && point.z <= maxW.z);

    if (!insideXZ)
    {
        outFace = ContactFace::None;
        outPushDirection = glm::vec3(0.0f);
        return false;
    }

    float topY = maxW.y;
    float bottomY = minW.y;
    float allowedTopY = topY + eyeHeight + collisionMargin;

    // Determine which face would be contacted
    if (point.y >= topY && point.y < allowedTopY)
    {
        outFace = ContactFace::Top;
        outPushDirection = glm::vec3(0.0f, 1.0f, 0.0f);
        return true;
    }

    if (point.y <= bottomY && point.y > bottomY - eyeHeight)
    {
        outFace = ContactFace::Bottom;
        outPushDirection = glm::vec3(0.0f, -1.0f, 0.0f);
        return true;
    }

    if (point.y > bottomY && point.y < topY)
    {
        float distToLeft = point.x - minW.x;
        float distToRight = maxW.x - point.x;
        float distToBack = point.z - minW.z;
        float distToFront = maxW.z - point.z;

        float minDist = std::min({ distToLeft, distToRight, distToBack, distToFront });

        if (minDist == distToLeft)
        {
            outFace = ContactFace::Left;
            outPushDirection = glm::vec3(-1.0f, 0.0f, 0.0f);
        }
        else if (minDist == distToRight)
        {
            outFace = ContactFace::Right;
            outPushDirection = glm::vec3(1.0f, 0.0f, 0.0f);
        }
        else if (minDist == distToBack)
        {
            outFace = ContactFace::Back;
            outPushDirection = glm::vec3(0.0f, 0.0f, -1.0f);
        }
        else
        {
            outFace = ContactFace::Front;
            outPushDirection = glm::vec3(0.0f, 0.0f, 1.0f);
        }
        return true;
    }

    outFace = ContactFace::None;
    outPushDirection = glm::vec3(0.0f);
    return false;
}

bool CollisionManager::isPointInsideAABB(const ICollidable* collidable, const glm::vec3& point) const
{
    if (!collidable)
        return false;

    glm::vec3 minW, maxW;
    collidable->getWorldAABB(minW, maxW);

    return (point.x >= minW.x && point.x <= maxW.x) &&
           (point.y >= minW.y && point.y <= maxW.y) &&
           (point.z >= minW.z && point.z <= maxW.z);
}