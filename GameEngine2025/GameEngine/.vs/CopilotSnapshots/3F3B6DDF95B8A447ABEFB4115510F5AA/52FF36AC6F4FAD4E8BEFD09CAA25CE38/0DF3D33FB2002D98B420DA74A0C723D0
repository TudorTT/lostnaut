#pragma once
#include "../Model Loading/mesh.h"
#include "../Shaders/shader.h"
#include "../Algorithms/collision.h"
#include <glm.hpp>
#include <gtc/matrix_transform.hpp>
#include <vector>

class Platform : public ICollidable
{
private:
	Mesh mesh;
	glm::vec3 position;
	glm::vec3 rotation;
	glm::vec3 scale;
	bool collisionEnabled;
	bool useOBBCollision;
	bool isHazard;  // NEW: If true, touching this resets the player
	std::string name;

	glm::vec3 meshMin;
	glm::vec3 meshMax;

	void computeMeshBounds();

public:
	Platform(const Mesh& mesh, const char* platformName = "Platform");
	
	void setPosition(const glm::vec3& p) { position = p; }
	void setRotation(const glm::vec3& r) { rotation = r; }
	void setScale(const glm::vec3& s) { scale = s; }
	void setName(const char* n) { name = n; }
	
	glm::vec3 getPosition() const { return position; }
	glm::vec3 getRotation() const { return rotation; }
	glm::vec3 getScale() const { return scale; }

	void setCollisionEnabled(bool enabled) { collisionEnabled = enabled; }
	void setUseOBBCollision(bool use) { useOBBCollision = use; }
	void setIsHazard(bool hazard) { isHazard = hazard; }  // NEW
	bool getIsHazard() const { return isHazard; }  // NEW

	void draw(Shader& shader, const glm::mat4& view, const glm::mat4& projection) const;

	// ICollidable interface
	void getWorldAABB(glm::vec3& outMin, glm::vec3& outMax) const override;
	bool isCollisionEnabled() const override { return collisionEnabled; }
	const char* getName() const override { return name.c_str(); }
	glm::mat4 getModelMatrix() const override;
	
	void getLocalBounds(glm::vec3& outMin, glm::vec3& outMax) const override {
		outMin = meshMin;
		outMax = meshMax;
	}
	
	bool usesOBBCollision() const override { return useOBBCollision; }
};